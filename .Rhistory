print(paste0("The minimum t-stat for beta 0 is ", min(T.matrix[, 1])))
#Print minimum beta 1 t-stat to user
print(paste0("The minimum t-stat for beta 1 is ", min(T.matrix[, 2])))
## Maximum t-stats for both coefficients (b0, b1)
c(max(T.matrix[, 1]),  max(T.matrix[, 2]) )
#Print maximum beta 0 t-stat to user
print(paste0("The maximum t-stat for beta 0 is ", max(T.matrix[, 1])))
#Print maximum beta 1 t-stat to user
print(paste0("The maximum t-stat for beta 1 is ", max(T.matrix[, 2])))
summary(OLS.result)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "p-value"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "p-value"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coefficients(summary(OLS.result))[, "p-value"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
yyy <- summary(OLS.result)
yyy
colnames(yyy)
names(yyy)
names(yyy["coefficients"])
coef
names(yyy)
residuals(OLS.result)
summary(OLS.result)
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = residuals(summary(OLS.result))[, "p-value"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "Residuals"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "Residuals"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = residuals(summary(OLS.result))[, "Residuals"]
PMatrix	= matrix(NA, Reps, 1)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = residuals(summary(OLS.result))[, "Residuals"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 1)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "Residuals"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 1)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = coef(summary(OLS.result))[, "p-value"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 1)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = residuals(summary(OLS.result))
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
PMatrix[ii, ]  = residuals(summary(OLS.result))
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
Obs       = 100		# Number of observations in each simulation
Reps      = 50		# Number of times we run the simulation
TrueBeta0	= 12000	# "True" beta0 for the simulated
TrueBeta1	= 1000	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed = 16 * runif(Obs)
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
PMatrix[ii, ]  = coef(summary(OLS.result))[, "p-value"]
SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
Obs       = 100		# Number of observations in each simulation
Reps      = 50		# Number of times we run the simulation
TrueBeta0	= 12000	# "True" beta0 for the simulated
TrueBeta1	= 1000	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed = 16 * runif(Obs)
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
PMatrix[ii, ]  = (summary(OLS.result))[, "p-value"]
SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
Obs       = 100		# Number of observations in each simulation
Reps      = 50		# Number of times we run the simulation
TrueBeta0	= 12000	# "True" beta0 for the simulated
TrueBeta1	= 1000	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed = 16 * runif(Obs)
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
PMatrix[ii, ]  = (summary(OLS.result))[, "p-value"]
SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
Obs       = 100		# Number of observations in each simulation
Reps      = 50		# Number of times we run the simulation
TrueBeta0	= 12000	# "True" beta0 for the simulated
TrueBeta1	= 1000	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed = 16 * runif(Obs)
PMatrix	= matrix(NA, Reps, 2)
for (ii in 1:Reps) {
PMatrix[ii, ]  = (summary(OLS.result))[, "p-values"]
SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
## For fun: plot results for each survey
## plot(Ed, Salary, pch = 19, col= "darkgreen")
## abline(OLS.result, lwd = 3, col= "darkgreen")
## Sys.sleep(0.075)		## Include to slow down calculations so we can see each plot (briefly); not necessary
}							 # This closes the "loop"
coef(summary(OLS.result))[, "p-values"]
coef(summary(OLS.result))[, "Std. Error"]
coef(summary(OLS.result))[, "F-statistic"]
coef(summary(OLS.result))[, "Residuals"]
coef(OLS.result)[, 4]
coef(OLS.result)[, 1]
coef(OLS.result)["p-value"]
T.matrix
T.matrix
T.matrix[,1]
pvals <- 2*(1-pt(abs(T.matrix),deg_freedom))
deg_freedom <- 98
pvals <- 2*(1-pt(abs(T.matrix),deg_freedom))
deg_freedom <- 98
P.Matrix = matrix(NA, Reps, 2)
# Matrix to store our results
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps) {
#OLS.result = lm(Salary ~ Ed) # Run a regression using simulated values of Y
#CoefMatrix[ii, ]	= coefficients(OLS.result)	 # Put OLS.result coefficients in row ii of CoefMatrix
#SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
P.Matrix[ii, ] = pvals
}
pvals
pvals <- 2*(1-pt(abs(T.matrix),deg_freedom))
deg_freedom <- 98
P.Matrix = matrix(NA, Reps, 2)
# Matrix to store our results
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps) {
#OLS.result = lm(Salary ~ Ed) # Run a regression using simulated values of Y
#CoefMatrix[ii, ]	= coefficients(OLS.result)	 # Put OLS.result coefficients in row ii of CoefMatrix
#SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
P.Matrix = pvals
}
P.Matrix
#Create two sided p values, and assign degrees of freedom from lm summary in 4a.
pvals <- 2*(1-pt(abs(T.matrix),deg_freedom))
deg_freedom <- 98
#Create P matrix with necessary shape to store results below
P.Matrix = matrix(NA, Reps, 2)
# For loop to assign p vals into the P Matrix
for (ii in 1:Reps) {
#OLS.result = lm(Salary ~ Ed) # Run a regression using simulated values of Y
#CoefMatrix[ii, ]	= coefficients(OLS.result)	 # Put OLS.result coefficients in row ii of CoefMatrix
#SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
P.Matrix = pvals
}
## Minimum t-stats for both coefficients (b0, b1)
c(min(P.Matrix[, 1]),  min(P.Matrix[, 2]) )
#Print minimum beta 0 p value to user
print(paste0("The minimum p value for beta 0 is ", min(P.Matrix[, 1])))
#Print minimum beta 1 p value to user
print(paste0("The minimum p value for beta 1 is ", min(P.Matrix[, 2])))
## Maximum p values for both coefficients (b0, b1)
c(max(P.Matrix[, 1]),  max(P.Matrix[, 2]) )
#Print maximum beta 0 p value to user
print(paste0("The maximum p value for beta 0 is ", max(P.Matrix[, 1])))
#Print maximum beta 1 p value to user
print(paste0("The maximum p value for beta 1 is ", max(P.Matrix[, 2])))
## Set model and simulation parameters
Obs_1       = 100		# Number of observations in each simulation
Reps_1      = 500		# Number of times we run the simulation
TrueBeta0_1	= 48	# "True" beta0 for the simulated
TrueBeta1_1	= 0	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed_1 = 16 * runif(Obs)# Simulate years of education as being between 0 and 16
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
CoefMatrix_1	= matrix(NA, Reps_1, 2)
SEMatrix_1    = matrix(NA, Reps_1, 2)
# Matrix to store our results - for both coefficients and std errors
# 1st argument is NA, meaning we store "not available" as initial values in the matrix
# 2nd argument is Reps, meaning the number of rows is equal to number of times we run the simulations
# 3rd argument is 2 meaning we have 2 columns, one for storing the beta0 estimate and one for storing the beta1 estimate
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps_1) {
Salary_1 	= TrueBeta0_1+ TrueBeta1_1* Ed_1 + SD*rnorm(Obs_1)
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
OLS.result_1 = lm(Salary_1 ~ Ed_1) # Run a regression using simulated values of Y
CoefMatrix_1[ii, ]	= coefficients(OLS.result_1)	 # Put OLS.result coefficients in row ii of CoefMatrix
SEMatrix_1[ii, ]  = coef(summary(OLS.result_1))[, "Std. Error"]
}
#T.matrix_1 = CoefMatrix_1/SEMatrix_1
T.matrix_1 = CoefMatrix_1/SEMatrix_1
summary(OLS.result_1)
## Set model and simulation parameters
Obs_1       = 100		# Number of observations in each simulation
Reps_1      = 500		# Number of times we run the simulation
TrueBeta0_1	= 48	# "True" beta0 for the simulated
TrueBeta1_1	= 0	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed_1 = 16 * runif(Obs)# Simulate years of education as being between 0 and 16
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
CoefMatrix_1	= matrix(NA, Reps_1, 2)
SEMatrix_1    = matrix(NA, Reps_1, 2)
# Matrix to store our results - for both coefficients and std errors
# 1st argument is NA, meaning we store "not available" as initial values in the matrix
# 2nd argument is Reps, meaning the number of rows is equal to number of times we run the simulations
# 3rd argument is 2 meaning we have 2 columns, one for storing the beta0 estimate and one for storing the beta1 estimate
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps_1) {
Salary_1 	= TrueBeta0_1+ TrueBeta1_1* Ed_1 + SD*rnorm(Obs_1)
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
OLS.result_1 = lm(Salary_1 ~ Ed_1) # Run a regression using simulated values of Y
CoefMatrix_1[ii, ]	= coefficients(OLS.result_1)	 # Put OLS.result coefficients in row ii of CoefMatrix
SEMatrix_1[ii, ]  = coef(summary(OLS.result_1))[, "Std. Error"]
}
T.matrix_1 = CoefMatrix_1/SEMatrix_1
#Create two sided p values, and assign degrees of freedom from lm summary in 4a.
pvals_1 <- 2*(1-pt(abs(T.matrix_1),deg_freedom_1))
## Set model and simulation parameters
Obs_1       = 100		# Number of observations in each simulation
Reps_1      = 500		# Number of times we run the simulation
TrueBeta0_1	= 48	# "True" beta0 for the simulated
TrueBeta1_1	= 0	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed_1 = 16 * runif(Obs)# Simulate years of education as being between 0 and 16
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
CoefMatrix_1	= matrix(NA, Reps_1, 2)
SEMatrix_1    = matrix(NA, Reps_1, 2)
# Matrix to store our results - for both coefficients and std errors
# 1st argument is NA, meaning we store "not available" as initial values in the matrix
# 2nd argument is Reps, meaning the number of rows is equal to number of times we run the simulations
# 3rd argument is 2 meaning we have 2 columns, one for storing the beta0 estimate and one for storing the beta1 estimate
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps_1) {
Salary_1 	= TrueBeta0_1+ TrueBeta1_1* Ed_1 + SD*rnorm(Obs_1)
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
OLS.result_1 = lm(Salary_1 ~ Ed_1) # Run a regression using simulated values of Y
CoefMatrix_1[ii, ]	= coefficients(OLS.result_1)	 # Put OLS.result coefficients in row ii of CoefMatrix
SEMatrix_1[ii, ]  = coef(summary(OLS.result_1))[, "Std. Error"]
}
T.matrix_1 = CoefMatrix_1/SEMatrix_1
#Create two sided p values, and assign degrees of freedom from lm summary in 4a.
deg_freedom_1 <- 98
pvals_1 <- 2*(1-pt(abs(T.matrix_1),deg_freedom_1))
#Create P matrix with necessary shape to store results below
P.Matrix_1 = matrix(NA, Reps_1, 2)
# For loop to assign p vals into the P Matrix
for (ii in 1:Reps_1) {
#OLS.result = lm(Salary ~ Ed) # Run a regression using simulated values of Y
#CoefMatrix[ii, ]	= coefficients(OLS.result)	 # Put OLS.result coefficients in row ii of CoefMatrix
#SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
P.Matrix_1 = pvals_1
}
## Minimum t-stats for both coefficients (b0, b1)
c(min(P.Matrix_1[, 1]),  min(P.Matrix_1[, 2]) )
#Print minimum beta 0 p value to user
print(paste0("The minimum p value for beta 0 is ", min(P.Matrix_1[, 1])))
#Print minimum beta 1 p value to user
print(paste0("The minimum p value for beta 1 is ", min(P.Matrix_1[, 2])))
## Maximum p values for both coefficients (b0, b1)
c(max(P.Matrix_1[, 1]),  max(P.Matrix_1[, 2]) )
## Set model and simulation parameters
Obs_1       = 100		# Number of observations in each simulation
Reps_1      = 500		# Number of times we run the simulation
TrueBeta0_1	= 48	# "True" beta0 for the simulated
TrueBeta1_1	= 0	# "True" beta1 for the simulated
SD 		    = 10000	# The standard deviation of the error. The bigger this is, the larger the average value of epsilon
Ed_1 = 16 * runif(Obs)# Simulate years of education as being between 0 and 16
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
CoefMatrix_1	= matrix(NA, Reps_1, 2)
SEMatrix_1    = matrix(NA, Reps_1, 2)
# Matrix to store our results - for both coefficients and std errors
# 1st argument is NA, meaning we store "not available" as initial values in the matrix
# 2nd argument is Reps, meaning the number of rows is equal to number of times we run the simulations
# 3rd argument is 2 meaning we have 2 columns, one for storing the beta0 estimate and one for storing the beta1 estimate
# Loop: repeat the commands between the brackets multiple times
for (ii in 1:Reps_1) {
Salary_1 	= TrueBeta0_1+ TrueBeta1_1* Ed_1 + SD*rnorm(Obs_1)
# Generate Salary = beta0 + beta1*Ed + epsilon
# beta0 is the constant
# beta1 is the number multiplied by the X variable
# Epsilon has 2 parts: SD is the standard deviation; the bigger it is, the more epsilon varies.
# "runif" is a uniform random variable between 0 and 1, with all values having equal probability
OLS.result_1 = lm(Salary_1 ~ Ed_1) # Run a regression using simulated values of Y
CoefMatrix_1[ii, ]	= coefficients(OLS.result_1)	 # Put OLS.result coefficients in row ii of CoefMatrix
SEMatrix_1[ii, ]  = coef(summary(OLS.result_1))[, "Std. Error"]
}
T.matrix_1 = CoefMatrix_1/SEMatrix_1
#Create two sided p values, and assign degrees of freedom from lm summary in 4a.
deg_freedom_1 <- 98
pvals_1 <- 2*(1-pt(abs(T.matrix_1),deg_freedom_1))
#Create P matrix with necessary shape to store results below
P.Matrix_1 = matrix(NA, Reps_1, 2)
# For loop to assign p vals into the P Matrix
for (ii in 1:Reps_1) {
#OLS.result = lm(Salary ~ Ed) # Run a regression using simulated values of Y
#CoefMatrix[ii, ]	= coefficients(OLS.result)	 # Put OLS.result coefficients in row ii of CoefMatrix
#SEMatrix[ii, ]  = coef(summary(OLS.result))[, "Std. Error"]
P.Matrix_1 = pvals_1
}
## Minimum t-stats for both coefficients (b0, b1)
c(min(P.Matrix_1[, 1]),  min(P.Matrix_1[, 2]) )
#Print minimum beta 0 p value to user
print(paste0("The minimum p value for beta 0 is ", min(P.Matrix_1[, 1])))
#Print minimum beta 1 p value to user
print(paste0("The minimum p value for beta 1 is ", min(P.Matrix_1[, 2])))
## Maximum p values for both coefficients (b0, b1)
c(max(P.Matrix_1[, 1]),  max(P.Matrix_1[, 2]) )
#Print maximum beta 0 p value to user
print(paste0("The maximum p value for beta 0 is ", max(P.Matrix_1[, 1])))
#Print maximum beta 1 p value to user
print(paste0("The maximum p value for beta 1 is ", max(P.Matrix_1[, 2])))
load("/Users/allenchurch/Documents/stats1/Ch3_Exercise3_Height_and_Wages_UK.RData")
load("Ch3_Exercise3_Height_and_Wages_UK.RData")
View(dta)
load("Ch3_Exercise3_Height_and_Wages_UK.RData")
data <- dta
View(data)
load("Ch3_Exercise3_Height_and_Wages_UK.RData")
data <- dta
data <- subset(data, gwage33 < 400 & height33 > 40)
View(data)
load("Ch3_Exercise3_Height_and_Wages_UK.RData")
data <- dta
#Subset data exclusing wages above 400 pounds/hr and height less than 40 inches
data <- subset(data, gwage33 < 400 & height33 > 40)
olsresults <- lm(data$gwage33 ~ data$height33)
summary(olsresults)
coefficients(olsresults)
coefficients(olsresults)["data$height33"]
print(coefficients(olsresults)["data$height33"])
coefficients(olsresults)[,"data$height33"]
coefficients(olsresults)[, "data$height33"]
coef(olsresults)[, "data$height33"]
coef(summary(olsresults))[, "data$height33"]
fitted.values(olsresults)
fitted(olsresults)
t_stat_beta0 <- -9.34591 / 5.01799
t_stat_beta1 <- 0.26810 / 0.07199
print(paste0("T stat for beta 0 is ",t_stat_beta0 ))
print(paste0("T stat for beta 1 is ",t_stat_beta1 ))
confidence <- confint(olsresults, level = 0.95)
confidence
print(confidence)
confidence <- confint(olsresults, level = 0.95)
confidence
View(data)
data800 <- data[1:800,]
olsresults2 <- lm(data800$gwage33 ~ data800$height33)
summary(olsresults2)
#Use cofint function and specify olsresults with a level of 0.95 as parameters
confidence <- confint(olsresults, level = 0.95)
confidence
nrow(data)
#Load data
load("Ch3_Exercise3_Height_and_Wages_UK.RData")
data <- dta
#Subset data exclusing wages above 400 pounds/hr and height less than 40 inches
data <- subset(data, gwage33 < 400 & height33 > 40)
#Run linear model and summarize results
olsresults <- lm(data$gwage33 ~ data$height33)
summary(olsresults)
